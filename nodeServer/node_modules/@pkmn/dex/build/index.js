"use strict";
var __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });
}) : (function(o, m, k, k2) {
    if (k2 === undefined) k2 = k;
    o[k2] = m[k];
}));
var __setModuleDefault = (this && this.__setModuleDefault) || (Object.create ? (function(o, v) {
    Object.defineProperty(o, "default", { enumerable: true, value: v });
}) : function(o, v) {
    o["default"] = v;
});
var __importStar = (this && this.__importStar) || function (mod) {
    if (mod && mod.__esModule) return mod;
    var result = {};
    if (mod != null) for (var k in mod) if (k !== "default" && Object.prototype.hasOwnProperty.call(mod, k)) __createBinding(result, mod, k);
    __setModuleDefault(result, mod);
    return result;
};
Object.defineProperty(exports, "__esModule", { value: true });
exports.Dex = exports.ModdedDex = exports.Type = exports.Learnset = exports.Species = exports.Nature = exports.Move = exports.Item = exports.Ability = exports.Condition = exports.BasicEffect = exports.toID = void 0;
const AbilitiesJSON = __importStar(require("./data/abilities.json"));
const AliasesJSON = __importStar(require("./data/aliases.json"));
const ConditionsJSON = __importStar(require("./data/conditions.json"));
const ItemsJSON = __importStar(require("./data/items.json"));
const MovesJSON = __importStar(require("./data/moves.json"));
const NaturesJSON = __importStar(require("./data/natures.json"));
const SpeciesJSON = __importStar(require("./data/species.json"));
const TypesJSON = __importStar(require("./data/types.json"));
const FormatsDataJSON = __importStar(require("./data/formats-data.json"));
function toID(text) {
    if (text === null || text === void 0 ? void 0 : text.id)
        text = text.id;
    if (typeof text !== 'string' && typeof text !== 'number')
        return '';
    return ('' + text).toLowerCase().replace(/[^a-z0-9]+/g, '');
}
exports.toID = toID;
function getString(str) {
    return (typeof str === 'string' || typeof str === 'number') ? '' + str : '';
}
class BasicEffect {
    constructor(data) {
        this.exists = true;
        Object.assign(this, data);
        this.name = getString(data.name).trim();
        this.id = data.realMove ? toID(data.realMove) : toID(this.name); // Hidden Power hack
        this.fullname = getString(data.fullname) || this.name;
        this.effectType = getString(data.effectType) || 'Condition';
        this.kind = 'Condition';
        this.exists = !!(this.exists && this.id);
        this.num = data.num || 0;
        this.gen = data.gen || 0;
        this.shortDesc = data.shortDesc || '';
        this.desc = data.desc || this.shortDesc;
        this.isNonstandard = data.isNonstandard || null;
        this.duration = data.duration;
    }
    toString() {
        return this.name;
    }
}
exports.BasicEffect = BasicEffect;
class Condition extends BasicEffect {
    constructor(data) {
        super(data);
        data = this;
        this.effectType =
            (['Weather', 'Status'].includes(data.effectType) ? data.effectType : 'Condition');
        this.kind = 'Condition';
    }
}
exports.Condition = Condition;
const EMPTY_CONDITION = new Condition({ name: '', exists: false });
class DexConditions {
    constructor(dex) {
        this.cache = Object.create(null);
        this.dex = dex;
    }
    get(name) {
        // This treatment of 'item:id' and 'ability:id' is kind of repugnant but regrettably exists
        // for loose compatibility with Pokémon Showdown's Dex API
        if (name.startsWith('item:')) {
            const item = this.dex.items.get(name.slice(5));
            return item;
        }
        else if (name.startsWith('ability:')) {
            const ability = this.dex.abilities.get(name.slice(8));
            return ability;
        }
        return this.getByID(toID(name));
    }
    getByID(id) {
        if (!id)
            return EMPTY_CONDITION;
        let condition = this.cache[id];
        if (condition)
            return condition;
        let found;
        if (this.dex.data.Conditions.hasOwnProperty(id)) {
            condition = new Condition(Object.assign({ kind: 'Condition' }, this.dex.data.Conditions[id]));
        }
        else if ((this.dex.data.Moves.hasOwnProperty(id) &&
            (found = this.dex.data.Moves[id]).condition) ||
            (this.dex.data.Abilities.hasOwnProperty(id) &&
                (found = this.dex.data.Abilities[id]).condition) ||
            (this.dex.data.Items.hasOwnProperty(id) &&
                (found = this.dex.data.Items[id]).condition)) {
            condition = new Condition(Object.assign({ name: found.name || id }, found.condition));
        }
        else if (id === 'recoil') {
            condition = new Condition({ name: 'Recoil', effectType: 'Recoil' });
        }
        else if (id === 'drain') {
            condition = new Condition({ name: 'Drain', effectType: 'Drain' });
        }
        else {
            condition = new Condition({ name: id, exists: false });
        }
        this.cache[id] = condition;
        return condition;
    }
}
class Ability extends BasicEffect {
    constructor(data) {
        super(data);
        data = this;
        this.fullname = `ability: ${this.name}`;
        this.effectType = 'Ability';
        this.kind = 'Ability';
        if (!this.gen) {
            if (this.num >= 234) {
                this.gen = 8;
            }
            else if (this.num >= 192) {
                this.gen = 7;
            }
            else if (this.num >= 165) {
                this.gen = 6;
            }
            else if (this.num >= 124) {
                this.gen = 5;
            }
            else if (this.num >= 77) {
                this.gen = 4;
            }
            else if (this.num >= 1) {
                this.gen = 3;
            }
        }
    }
}
exports.Ability = Ability;
class DexAbilities {
    constructor(dex) {
        this.caches = {
            get: Object.create(null),
            all: undefined,
        };
        this.dex = dex;
    }
    get(name) {
        return this.getByID(toID(name));
    }
    getByID(id) {
        const alias = this.dex.data.Aliases[id];
        if (alias)
            id = toID(alias);
        let ability = this.caches.get[id];
        if (ability)
            return ability;
        const data = this.dex.data.Abilities[id];
        if (id && data) {
            ability = new Ability(data);
            if (ability.gen > this.dex.gen)
                ability.isNonstandard = 'Future';
            if (this.dex.gen <= 2 && ability.id === 'noability')
                ability.isNonstandard = null;
        }
        else {
            ability = new Ability({ id, name: id, exists: false });
        }
        if (ability.exists)
            this.caches.get[id] = ability;
        return ability;
    }
    all() {
        if (this.caches.all)
            return this.caches.all;
        const abilities = [];
        for (const id in this.dex.data.Abilities) {
            abilities.push(this.getByID(id));
        }
        return (this.caches.all = abilities);
    }
}
class Item extends BasicEffect {
    constructor(data) {
        super(data);
        data = this;
        this.fullname = `item: ${this.name}`;
        this.effectType = 'Item';
        this.kind = 'Item';
        if (!this.gen) {
            if (this.num >= 689) {
                this.gen = 7;
            }
            else if (this.num >= 577) {
                this.gen = 6;
            }
            else if (this.num >= 537) {
                this.gen = 5;
            }
            else if (this.num >= 377) {
                this.gen = 4;
            }
            else {
                this.gen = 3;
            }
            // Due to difference in gen 2 item numbering, gen 2 items must be
            // specified manually
        }
        if (this.isBerry)
            this.fling = { basePower: 10 };
        if (this.id.endsWith('plate'))
            this.fling = { basePower: 90 };
        if (this.onDrive)
            this.fling = { basePower: 70 };
        if (this.megaStone)
            this.fling = { basePower: 80 };
        if (this.onMemory)
            this.fling = { basePower: 50 };
    }
}
exports.Item = Item;
class DexItems {
    constructor(dex) {
        this.caches = {
            get: Object.create(null),
            all: undefined,
        };
        this.dex = dex;
    }
    get(name) {
        return this.getByID(toID(name));
    }
    getByID(id) {
        const alias = this.dex.data.Aliases[id];
        if (alias)
            id = toID(alias);
        let item = this.caches.get[id];
        if (item)
            return item;
        if (id && !this.dex.data.Items[id] && this.dex.data.Items[id + 'berry']) {
            item = this.getByID(id + 'berry');
            return (this.caches.get[id] = item);
        }
        const data = this.dex.data.Items[id];
        if (id && data) {
            item = new Item(data);
            if (item.gen > this.dex.gen)
                item.isNonstandard = 'Future';
        }
        else {
            item = new Item({ name: id, exists: false });
        }
        if (item.exists)
            this.caches.get[id] = item;
        return item;
    }
    all() {
        if (this.caches.all)
            return this.caches.all;
        const items = [];
        for (const id in this.dex.data.Items) {
            items.push(this.getByID(id));
        }
        return (this.caches.all = items);
    }
}
class Move extends BasicEffect {
    constructor(data) {
        var _a;
        super(data);
        data = this;
        this.fullname = `move: ${this.name}`;
        this.effectType = 'Move';
        this.kind = 'Move';
        this.type = getString(data.type);
        this.basePower = Number(data.basePower);
        this.critRatio = Number(data.critRatio) || 1;
        this.secondary = data.secondary || null;
        this.secondaries = ((_a = data.secondaries) === null || _a === void 0 ? void 0 : _a.length)
            ? data.secondaries : this.secondary
            ? [this.secondary]
            : null;
        this.priority = Number(data.priority) || 0;
        this.ignoreImmunity =
            (data.ignoreImmunity !== undefined ? data.ignoreImmunity : data.category === 'Status');
        this.pp = Number(data.pp);
        this.isZ = data.isZ || false;
        this.isMax = data.isMax || false;
        this.flags = data.flags || {};
        this.selfSwitch =
            (typeof data.selfSwitch === 'string'
                ? data.selfSwitch
                : data.selfSwitch) ||
                undefined;
        this.pressureTarget = data.pressureTarget || undefined;
        this.nonGhostTarget = data.nonGhostTarget || undefined;
        this.ignoreAbility = data.ignoreAbility || false;
        this.volatileStatus =
            typeof data.volatileStatus === 'string' ? data.volatileStatus : undefined;
        if (this.category !== 'Status' && !this.maxMove && this.id !== 'struggle') {
            this.maxMove = { basePower: 1 };
            if (this.isMax || this.isZ) {
                // already initialized to 1
            }
            else if (!this.basePower) {
                this.maxMove.basePower = 100;
            }
            else if (['Fighting', 'Poison'].includes(this.type)) {
                if (this.basePower >= 150) {
                    this.maxMove.basePower = 100;
                }
                else if (this.basePower >= 110) {
                    this.maxMove.basePower = 95;
                }
                else if (this.basePower >= 75) {
                    this.maxMove.basePower = 90;
                }
                else if (this.basePower >= 65) {
                    this.maxMove.basePower = 85;
                }
                else if (this.basePower >= 55) {
                    this.maxMove.basePower = 80;
                }
                else if (this.basePower >= 45) {
                    this.maxMove.basePower = 75;
                }
                else {
                    this.maxMove.basePower = 70;
                }
            }
            else {
                if (this.basePower >= 150) {
                    this.maxMove.basePower = 150;
                }
                else if (this.basePower >= 110) {
                    this.maxMove.basePower = 140;
                }
                else if (this.basePower >= 75) {
                    this.maxMove.basePower = 130;
                }
                else if (this.basePower >= 65) {
                    this.maxMove.basePower = 120;
                }
                else if (this.basePower >= 55) {
                    this.maxMove.basePower = 110;
                }
                else if (this.basePower >= 45) {
                    this.maxMove.basePower = 100;
                }
                else {
                    this.maxMove.basePower = 90;
                }
            }
        }
        if (this.category !== 'Status' && !this.zMove &&
            !this.isZ && !this.isMax && this.id !== 'struggle') {
            let basePower = this.basePower;
            this.zMove = {};
            if (Array.isArray(this.multihit))
                basePower *= 3;
            if (!basePower) {
                this.zMove.basePower = 100;
            }
            else if (basePower >= 140) {
                this.zMove.basePower = 200;
            }
            else if (basePower >= 130) {
                this.zMove.basePower = 195;
            }
            else if (basePower >= 120) {
                this.zMove.basePower = 190;
            }
            else if (basePower >= 110) {
                this.zMove.basePower = 185;
            }
            else if (basePower >= 100) {
                this.zMove.basePower = 180;
            }
            else if (basePower >= 90) {
                this.zMove.basePower = 175;
            }
            else if (basePower >= 80) {
                this.zMove.basePower = 160;
            }
            else if (basePower >= 70) {
                this.zMove.basePower = 140;
            }
            else if (basePower >= 60) {
                this.zMove.basePower = 120;
            }
            else {
                this.zMove.basePower = 100;
            }
        }
        if (!this.gen) {
            if (this.num >= 743) {
                this.gen = 8;
            }
            else if (this.num >= 622) {
                this.gen = 7;
            }
            else if (this.num >= 560) {
                this.gen = 6;
            }
            else if (this.num >= 468) {
                this.gen = 5;
            }
            else if (this.num >= 355) {
                this.gen = 4;
            }
            else if (this.num >= 252) {
                this.gen = 3;
            }
            else if (this.num >= 166) {
                this.gen = 2;
            }
            else if (this.num >= 1) {
                this.gen = 1;
            }
        }
    }
}
exports.Move = Move;
class DexMoves {
    constructor(dex) {
        this.caches = {
            get: Object.create(null),
            all: undefined,
        };
        this.dex = dex;
    }
    get(name) {
        return this.getByID(toID(name));
    }
    getByID(id) {
        const alias = this.dex.data.Aliases[id];
        if (alias)
            id = toID(alias);
        let move = this.caches.get[id];
        if (move)
            return move;
        if (id.startsWith('hiddenpower')) {
            id = /([a-z]*)([0-9]*)/.exec(id)[1];
        }
        const data = this.dex.data.Moves[id];
        if (id && data) {
            move = new Move(data);
            if (id.substr(0, 11) === 'hiddenpower') {
                id = /([a-z]*)([0-9]*)/.exec(id)[1];
            }
            else if (id.substr(0, 6) === 'return' && id.length > 6) {
                id = 'return';
                move.basePower = Number(id.slice(6));
            }
            else if (id.substr(0, 11) === 'frustration' && id.length > 11) {
                id = 'frustration';
                move.basePower = Number(id.slice(11));
            }
            if (this.dex.gen <= 3 && data.category !== 'Status') {
                move.category = getGen3Category(data.type);
            }
            if (move.gen > this.dex.gen)
                move.isNonstandard = 'Future';
        }
        else {
            move = new Move({ id, name: id, exists: false });
        }
        if (move.exists)
            this.caches.get[id] = move;
        return move;
    }
    all() {
        if (this.caches.all)
            return this.caches.all;
        const moves = [];
        for (const id in this.dex.data.Moves) {
            moves.push(this.getByID(id));
        }
        return (this.caches.all = moves);
    }
}
class Nature extends BasicEffect {
    constructor(data) {
        super(data);
        data = this;
        this.fullname = `nature: ${this.name}`;
        this.effectType = 'Nature';
        this.kind = 'Nature';
        this.gen = 3;
        this.plus = data.plus || undefined;
        this.minus = data.minus || undefined;
    }
}
exports.Nature = Nature;
class DexNatures {
    constructor(dex) {
        this.caches = {
            get: Object.create(null),
            all: undefined,
        };
        this.dex = dex;
    }
    get(name) {
        return this.getByID(toID(name));
    }
    getByID(id) {
        const alias = this.dex.data.Aliases[id];
        if (alias)
            id = toID(alias);
        let nature = this.caches.get[id];
        if (nature)
            return nature;
        const data = this.dex.data.Natures[id];
        if (id && data) {
            nature = new Nature(data);
            if (nature.gen > this.dex.gen)
                nature.isNonstandard = 'Future';
        }
        else {
            nature = new Nature({ name: id, exists: false });
        }
        if (nature.exists)
            this.caches.get[id] = nature;
        return nature;
    }
    all() {
        if (this.caches.all)
            return this.caches.all;
        const natures = [];
        for (const id in this.dex.data.Natures) {
            natures.push(this.getByID(id));
        }
        return (this.caches.all = natures);
    }
}
class Species extends BasicEffect {
    constructor(data) {
        var _a;
        super(data);
        data = this;
        this.fullname = `pokemon: ${data.name}`;
        this.effectType = 'Pokemon';
        this.kind = 'Species';
        this.baseSpecies = data.baseSpecies || data.name;
        this.forme = data.forme || '';
        this.baseForme = data.baseForme || '';
        this.abilities = data.abilities || { 0: '' };
        this.types = data.types || ['???'];
        this.prevo = data.prevo || '';
        this.tier = data.tier || '';
        this.doublesTier = data.doublesTier || '';
        this.evos = data.evos || [];
        this.nfe = !!((_a = this.evos) === null || _a === void 0 ? void 0 : _a.length);
        this.eggGroups = data.eggGroups || [];
        this.canHatch = data.canHatch || false;
        this.genderRatio = data.genderRatio || (this.gender === 'M' ? { M: 1, F: 0 }
            : this.gender === 'F' ? { M: 0, F: 1 }
                : this.gender === 'N' ? { M: 0, F: 0 }
                    : { M: 0.5, F: 0.5 });
        this.requiredItem = data.requiredItem || undefined;
        this.requiredItems =
            this.requiredItems || (this.requiredItem ? [this.requiredItem] : undefined);
        this.baseStats = data.baseStats || { hp: 0, atk: 0, def: 0, spa: 0, spd: 0, spe: 0 };
        this.bst = this.baseStats.hp + this.baseStats.atk + this.baseStats.def +
            this.baseStats.spa + this.baseStats.spd + this.baseStats.spe;
        this.weightkg = data.weightkg || 0;
        this.weighthg = this.weightkg * 10;
        this.tags = data.tags || [];
        this.unreleasedHidden = data.unreleasedHidden || false;
        this.maleOnlyHidden = !!data.maleOnlyHidden;
        this.maxHP = data.maxHP || undefined;
        this.isMega = !!(this.forme && ['Mega', 'Mega-X', 'Mega-Y'].includes(this.forme)) || undefined;
        this.canGigantamax = data.canGigantamax || undefined;
        this.gmaxUnreleased = !!data.gmaxUnreleased;
        this.cannotDynamax = !!data.cannotDynamax;
        this.battleOnly = data.battleOnly || (this.isMega ? this.baseSpecies : undefined);
        this.changesFrom = data.changesFrom ||
            (this.battleOnly !== this.baseSpecies ? this.battleOnly : this.baseSpecies);
        if (Array.isArray(data.changesFrom))
            this.changesFrom = data.changesFrom[0]; // BUG
        if (!this.gen && data.num >= 1) {
            if (data.num >= 810 || ['Gmax', 'Galar', 'Galar-Zen'].includes(this.forme)) {
                this.gen = 8;
            }
            else if (data.num >= 722 || this.forme.startsWith('Alola') || this.forme === 'Starter') {
                this.gen = 7;
            }
            else if (this.forme === 'Primal') {
                this.gen = 6;
                this.isPrimal = true;
                this.battleOnly = this.baseSpecies;
            }
            else if (data.num >= 650 || this.isMega) {
                this.gen = 6;
            }
            else if (data.num >= 494) {
                this.gen = 5;
            }
            else if (data.num >= 387) {
                this.gen = 4;
            }
            else if (data.num >= 252) {
                this.gen = 3;
            }
            else if (data.num >= 152) {
                this.gen = 2;
            }
            else {
                this.gen = 1;
            }
        }
    }
}
exports.Species = Species;
class DexSpecies {
    constructor(dex) {
        this.caches = {
            get: Object.create(null),
            all: undefined,
        };
        this.dex = dex;
    }
    get(name) {
        name = name.trim();
        let id = toID(name);
        if (id === 'nidoran' && name.endsWith('♀')) {
            id = 'nidoranf';
        }
        else if (id === 'nidoran' && name.endsWith('♂')) {
            id = 'nidoranm';
        }
        return this.getByID(id);
    }
    getByID(id) {
        var _a;
        let species = this.caches.get[id];
        if (species)
            return species;
        const alias = this.dex.data.Aliases[id];
        if (alias) {
            const data = this.dex.data.FormatsData[id];
            if (data) {
                // special event ID, like Rockruff-Dusk
                const baseId = toID(alias);
                species = new Species(Object.assign(Object.assign(Object.assign({}, this.dex.data.Species[baseId]), this.dex.data.FormatsData[id]), { name: id }));
                species.abilities = { 0: species.abilities['S'] };
            }
            else {
                species = this.get(alias);
                if (species.cosmeticFormes) {
                    for (const forme of species.cosmeticFormes) {
                        if (toID(forme) === id) {
                            species = new Species(Object.assign(Object.assign({}, species), { name: forme, id, forme: forme.slice(species.name.length + 1), baseForme: '', baseSpecies: species.name, otherFormes: null, cosmeticFormes: null }));
                            break;
                        }
                    }
                }
            }
            if (species === null || species === void 0 ? void 0 : species.exists)
                this.caches.get[id] = species;
            return species;
        }
        let data = this.dex.data.Species[id];
        if (id && !data) {
            let aliasTo = '';
            const formeNames = {
                alola: ['a', 'alola', 'alolan'],
                galar: ['g', 'galar', 'galarian'],
                mega: ['m', 'mega'],
                primal: ['p', 'primal'],
            };
            for (const forme in formeNames) {
                let pokeName = '';
                for (const i of formeNames[forme]) {
                    if (id.startsWith(i)) {
                        pokeName = id.slice(i.length);
                    }
                    else if (id.endsWith(i)) {
                        pokeName = id.slice(0, -i.length);
                    }
                }
                if (this.dex.data.Aliases.hasOwnProperty(pokeName)) {
                    pokeName = toID(this.dex.data.Aliases[pokeName]);
                }
                if (this.dex.data.Species[pokeName + forme]) {
                    aliasTo = pokeName + forme;
                    break;
                }
            }
            if (aliasTo) {
                species = this.get(aliasTo);
                if (species.exists) {
                    this.caches.get[id] = species;
                    return species;
                }
            }
        }
        data = this.dex.data.Species[id];
        if (id && data) {
            const tags = data.baseSpecies && this.dex.data.Species[toID(data.baseSpecies)].tags;
            species = new Species(Object.assign(Object.assign({ tags }, data), this.dex.data.FormatsData[id]));
            if (!species.tier && !species.doublesTier && species.baseSpecies !== species.name) {
                if (species.baseSpecies === 'Mimikyu') {
                    species.tier =
                        this.dex.data.FormatsData[toID(species.baseSpecies)].tier || 'Illegal';
                    species.doublesTier =
                        this.dex.data.FormatsData[toID(species.baseSpecies)].doublesTier || 'Illegal';
                }
                else if (species.id.endsWith('totem')) {
                    species.tier =
                        this.dex.data.FormatsData[species.id.slice(0, -5)].tier || 'Illegal';
                    species.doublesTier =
                        this.dex.data.FormatsData[species.id.slice(0, -5)].doublesTier || 'Illegal';
                }
                else if (species.battleOnly) {
                    species.tier =
                        this.dex.data.FormatsData[toID(species.battleOnly)].tier || 'Illegal';
                    species.doublesTier =
                        this.dex.data.FormatsData[toID(species.battleOnly)].doublesTier || 'Illegal';
                }
                else {
                    const baseFormatsData = this.dex.data.FormatsData[toID(species.baseSpecies)];
                    if (!baseFormatsData) {
                        throw new Error(`${species.baseSpecies} has no formats-data entry`);
                    }
                    species.tier = baseFormatsData.tier || 'Illegal';
                    species.doublesTier = baseFormatsData.doublesTier || 'Illegal';
                }
            }
            if (!species.tier)
                species.tier = 'Illegal';
            if (!species.doublesTier)
                species.doublesTier = species.tier;
            if (species.gen > this.dex.gen) {
                species.tier = 'Illegal';
                species.doublesTier = 'Illegal';
                species.isNonstandard = 'Future';
            }
            species.nfe = !!(((_a = species.evos) === null || _a === void 0 ? void 0 : _a.length) && this.get(species.evos[0]).gen <= this.dex.gen);
            species.canHatch = species.canHatch ||
                (!['Ditto', 'Undiscovered'].includes(species.eggGroups[0]) && !species.prevo && species.name !== 'Manaphy');
            if (this.dex.gen === 1)
                species.bst -= species.baseStats.spd;
            if (this.dex.gen < 5)
                delete species.abilities['H'];
        }
        else {
            species = new Species({
                id, name: id,
                exists: false, tier: 'Illegal', doublesTier: 'Illegal', isNonstandard: 'Custom',
            });
        }
        if (species.exists)
            this.caches.get[id] = species;
        return species;
    }
    all() {
        if (this.caches.all)
            return this.caches.all;
        const species = [];
        for (const id in this.dex.data.Species) {
            species.push(this.getByID(id));
        }
        return (this.caches.all = species);
    }
}
class Learnset {
    constructor(data) {
        var _a;
        this.effectType = 'Learnset';
        this.kind = 'Learnset';
        this.learnset = data.learnset || undefined;
        this.eventOnly = !!data.eventOnly;
        this.eventData = data.eventData || undefined;
        this.encounters = data.encounters || undefined;
        this.exists = (_a = data.exists) !== null && _a !== void 0 ? _a : true;
    }
}
exports.Learnset = Learnset;
class DexLearnsets {
    constructor(dex) {
        this.cache = Object.create(null);
        this.dex = dex;
    }
    async get(name) {
        return this.getByID(toID(name));
    }
    async getByID(id) {
        let learnset = this.cache[id];
        if (learnset)
            return learnset;
        if (!DATA.Learnsets) {
            const isNode = typeof process !== 'undefined' &&
                process.versions !== null &&
                process.versions.node !== null;
            if (isNode) {
                DATA.Learnsets = require('./data/learnsets.json');
            }
            else {
                try {
                    // Cast required since Typescript thinks asynchronously imported JSON have default exports
                    DATA.Learnsets =
                        (await Promise.resolve().then(() => __importStar(require('./data/learnsets.json'))));
                }
                catch (err) {
                    // @ts-ignore If we're being used via a <script> tag we depend on Learnsets being required
                    DATA.Learnsets = window.DexLearnsets;
                    if (!DATA.Learnsets)
                        throw new Error('Learnsets have not been included!');
                }
            }
        }
        this.dex.load('Learnsets', this.dex.modData);
        this.dex.modData = undefined;
        const data = this.dex.data.Learnsets[id];
        if (id && data) {
            learnset = new Learnset(data);
        }
        else {
            learnset = new Learnset({ exists: false });
        }
        if (learnset.exists)
            this.cache[id] = learnset;
        return learnset;
    }
}
class Type {
    constructor(data) {
        this.exists = true;
        Object.assign(this, data);
        this.effectType = 'Type';
        this.kind = 'Type';
        this.id = data.id;
        this.name = data.name;
        this.exists = !!(this.exists && this.id);
        this.gen = data.gen || 0;
        this.isNonstandard = data.isNonstandard || null;
        this.damageTaken = data.damageTaken || {};
        this.HPivs = data.HPivs || {};
        this.HPdvs = data.HPdvs || {};
    }
    toString() {
        return this.name;
    }
}
exports.Type = Type;
class DexTypes {
    constructor(dex) {
        this.caches = {
            get: Object.create(null),
            all: undefined,
            names: undefined,
        };
        this.dex = dex;
    }
    get(name) {
        if (name && typeof name !== 'string')
            return name;
        return this.getByID(toID(name));
    }
    getByID(id) {
        const alias = this.dex.data.Aliases[id];
        if (alias)
            id = toID(alias);
        let type = this.caches.get[id];
        if (type)
            return type;
        const typeName = id.charAt(0).toUpperCase() + id.substr(1);
        const data = this.dex.data.Types[id];
        if (typeName && data) {
            type = new Type(Object.assign({ name: typeName, id }, data));
        }
        else {
            type = new Type({ name: typeName, id, exists: false });
        }
        if (type.exists)
            this.caches.get[id] = type;
        return type;
    }
    names() {
        if (this.caches.names)
            return this.caches.names;
        this.caches.names = this.all().filter(type => !type.isNonstandard).map(type => type.name);
        return this.caches.names;
    }
    isName(name) {
        const id = name.toLowerCase();
        const typeName = id.charAt(0).toUpperCase() + id.substr(1);
        return name === typeName && this.dex.data.Types.hasOwnProperty(id);
    }
    all() {
        if (this.caches.all)
            return this.caches.all;
        const types = [];
        for (const id in this.dex.data.Types) {
            types.push(this.getByID(id));
        }
        return (this.caches.all = types);
    }
}
const STATS = ['hp', 'atk', 'def', 'spa', 'spd', 'spe'];
class DexStats {
    constructor(dex) {
        if (dex.gen !== 1) {
            this.shortNames = {
                __proto__: null,
                hp: 'HP', atk: 'Atk', def: 'Def',
                spa: 'SpA', spd: 'SpD', spe: 'Spe',
            };
            this.mediumNames = {
                __proto__: null,
                hp: 'HP', atk: 'Attack', def: 'Defense',
                spa: 'Sp. Atk', spd: 'Sp. Def', spe: 'Speed',
            };
            this.names = {
                __proto__: null,
                hp: 'HP', atk: 'Attack', def: 'Defense',
                spa: 'Special Attack', spd: 'Special Defense', spe: 'Speed',
            };
        }
        else {
            this.shortNames = {
                __proto__: null,
                hp: 'HP', atk: 'Atk', def: 'Def',
                spa: 'Spc', spd: '[SpD]', spe: 'Spe',
            };
            this.mediumNames = {
                __proto__: null,
                hp: 'HP', atk: 'Attack', def: 'Defense',
                spa: 'Special', spd: '[Sp. Def]', spe: 'Speed',
            };
            this.names = {
                __proto__: null,
                hp: 'HP', atk: 'Attack', def: 'Defense',
                spa: 'Special', spd: '[Special Defense]', spe: 'Speed',
            };
        }
    }
    ids() {
        return STATS;
    }
}
const DATA = {
    Abilities: AbilitiesJSON,
    Aliases: AliasesJSON,
    Conditions: ConditionsJSON,
    Items: ItemsJSON,
    Moves: MovesJSON,
    Species: SpeciesJSON,
    Natures: NaturesJSON,
    Learnsets: null,
    Types: TypesJSON,
    FormatsData: FormatsDataJSON,
};
const HP_TYPES = [
    'Fighting', 'Flying', 'Poison', 'Ground', 'Rock', 'Bug', 'Ghost', 'Steel',
    'Fire', 'Water', 'Grass', 'Electric', 'Psychic', 'Ice', 'Dragon', 'Dark',
];
const GEN_IDS = ['gen1', 'gen2', 'gen3', 'gen4', 'gen5', 'gen6', 'gen7', 'gen8'];
const CURRENT_GEN_ID = GEN_IDS[7];
const dexes = Object.create(null);
class ModdedDex {
    constructor(modid = CURRENT_GEN_ID, modData) {
        var _a, _b;
        /* private */ this.modData = undefined;
        const isGen = GEN_IDS.includes(modid);
        if (!isGen && !modData)
            throw new Error(`Must provide mod data with mod '${modid}'`);
        this.modid = modid;
        this.gen = parseInt(((_b = (_a = modData === null || modData === void 0 ? void 0 : modData.Scripts) === null || _a === void 0 ? void 0 : _a.inherit) !== null && _b !== void 0 ? _b : modid).slice(3)) || 8;
        this.loadData(modData);
        this.abilities = new DexAbilities(this);
        this.conditions = new DexConditions(this);
        this.items = new DexItems(this);
        this.learnsets = new DexLearnsets(this);
        this.moves = new DexMoves(this);
        this.natures = new DexNatures(this);
        this.species = new DexSpecies(this);
        this.stats = new DexStats(this);
        this.types = new DexTypes(this);
    }
    mod(modid, modData) {
        if (modid in dexes)
            return modData ? new ModdedDex(modid, modData) : dexes[modid];
        return (dexes[modid] = new ModdedDex(modid, modData));
    }
    forGen(gen) {
        if (!gen)
            return this;
        return this.mod(`gen${gen}`);
    }
    getImmunity(source, target) {
        var _a;
        const sourceType = typeof source !== 'string' ? source.type : source;
        // @ts-ignore
        const targetTyping = ((_a = target.getTypes) === null || _a === void 0 ? void 0 : _a.call(target)) || target.types || target;
        if (Array.isArray(targetTyping)) {
            for (const type of targetTyping) {
                if (!this.getImmunity(sourceType, type))
                    return false;
            }
            return true;
        }
        const typeData = this.types.get(targetTyping);
        if (typeData && typeData.damageTaken[sourceType] === 3)
            return false;
        return true;
    }
    getEffectiveness(source, target) {
        var _a;
        const sourceType = typeof source !== 'string' ? source.type : source;
        // @ts-ignore
        const targetTyping = ((_a = target.getTypes) === null || _a === void 0 ? void 0 : _a.call(target)) || target.types || target;
        let totalTypeMod = 0;
        if (Array.isArray(targetTyping)) {
            for (const type of targetTyping) {
                totalTypeMod += this.getEffectiveness(sourceType, type);
            }
            return totalTypeMod;
        }
        const typeData = this.types.get(targetTyping);
        if (!typeData)
            return 0;
        switch (typeData.damageTaken[sourceType]) {
            case 1: return 1; // super-effective
            case 2: return -1; // resist
            // in case of weird situations like Gravity, immunity is handled elsewhere
            default: return 0;
        }
    }
    getHiddenPower(ivs) {
        const tr = (num, bits = 0) => {
            if (bits)
                return (num >>> 0) % (2 ** bits);
            return num >>> 0;
        };
        const stats = { hp: 31, atk: 31, def: 31, spe: 31, spa: 31, spd: 31 };
        if (this.gen <= 2) {
            // Gen 2 specific Hidden Power check. IVs are still treated 0-31 so we get them 0-15
            const atkDV = tr(ivs.atk / 2);
            const defDV = tr(ivs.def / 2);
            const speDV = tr(ivs.spe / 2);
            const spcDV = tr(ivs.spa / 2);
            return {
                type: HP_TYPES[4 * (atkDV % 4) + (defDV % 4)],
                power: tr((5 * ((spcDV >> 3) +
                    (2 * (speDV >> 3)) +
                    (4 * (defDV >> 3)) +
                    (8 * (atkDV >> 3))) +
                    (spcDV % 4)) / 2 + 31),
            };
        }
        else {
            // Hidden Power check for Gen 3 onwards
            let hpTypeX = 0;
            let hpPowerX = 0;
            let i = 1;
            for (const s in stats) {
                hpTypeX += i * (ivs[s] % 2);
                hpPowerX += i * (tr(ivs[s] / 2) % 2);
                i *= 2;
            }
            return {
                type: HP_TYPES[tr(hpTypeX * 15 / 63)],
                // After Gen 6, Hidden Power is always 60 base power
                power: (this.gen && this.gen < 6) ? tr(hpPowerX * 40 / 63) + 30 : 60,
            };
        }
    }
    includeModData() {
        return this;
    }
    includeData() {
        return this;
    }
    includeFormats() {
        return this;
    }
    loadData(modData) {
        if (this.data)
            return this.data;
        this.data = {};
        for (const t in DATA) {
            const type = t;
            if (type === 'Learnsets') {
                this.modData = modData;
                continue; // async
            }
            if (type === 'Aliases') {
                this.data[type] = DATA[type];
                continue;
            }
            this.load(type, modData);
        }
        return this.data;
    }
    load(type, modData) {
        var _a, _b;
        if (this.data[type])
            return;
        const d = modData ? modData[type] : DATA[type][this.gen];
        if (d !== this.data[type])
            this.data[type] = (Object.assign(Object.assign({}, d), this.data[type]));
        if (this.modid === CURRENT_GEN_ID)
            return;
        const parentDex = ((_a = modData === null || modData === void 0 ? void 0 : modData.Scripts) === null || _a === void 0 ? void 0 : _a.inherit)
            ? this.mod(modData.Scripts.inherit)
            : this.forGen(modData ? this.gen : this.gen + 1);
        if (type === 'Learnsets')
            parentDex.load('Learnsets');
        const parentDataType = parentDex.data[type];
        const childDataType = this.data[type] || (this.data[type] = {});
        for (const e in parentDataType) {
            const entry = e;
            if (childDataType[entry] === null) {
                // null means don't inherit
                delete childDataType[entry];
            }
            else if (!(entry in childDataType)) {
                // If it doesn't exist it's inherited from the parent data
                if (type === 'Species') {
                    // Species entries can be modified too many different ways
                    // e.g. inheriting different formats-data/learnsets
                    childDataType[entry] = deepClone(parentDataType[entry]);
                }
                else {
                    childDataType[entry] = parentDataType[entry];
                }
            }
            else if ((_b = childDataType[entry]) === null || _b === void 0 ? void 0 : _b.inherit) {
                // {inherit: true} can be used to modify only parts of the parent data,
                // instead of overwriting entirely
                delete childDataType[entry].inherit;
                // Merge parent into children entry, preserving existing childs' properties.
                for (const key in parentDataType[entry]) {
                    if (key in childDataType[entry])
                        continue;
                    (childDataType[entry])[key] = parentDataType[entry][key];
                }
            }
        }
    }
}
exports.ModdedDex = ModdedDex;
ModdedDex.STATS = ['hp', 'atk', 'def', 'spa', 'spd', 'spe'];
const SPECIAL = ['Fire', 'Water', 'Grass', 'Electric', 'Ice', 'Psychic', 'Dark', 'Dragon'];
function getGen3Category(type) {
    return SPECIAL.includes(type) ? 'Special' : 'Physical';
}
function deepClone(obj) {
    if (obj === null || typeof obj !== 'object')
        return obj;
    if (Array.isArray(obj))
        return obj.map(prop => deepClone(prop));
    const clone = Object.create(Object.getPrototypeOf(obj));
    for (const key of Object.keys(obj)) {
        clone[key] = deepClone(obj[key]);
    }
    return clone;
}
// #endregion
dexes[CURRENT_GEN_ID] = new ModdedDex(CURRENT_GEN_ID);
exports.Dex = dexes[CURRENT_GEN_ID];
//# sourceMappingURL=index.js.map